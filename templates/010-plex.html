{% extends "000-base.html" %} {% block content %}
<form action="/step/020-tmdb" method="post" id="configForm" name="configForm">
  <div id="plexSection">
    <h2>Plex Settings</h2>
    <hr class="hr">
    <div class="alert alert-danger" role="alert">
      This section is mandatory and must be completed<br>
      <a href="#" data-bs-toggle="modal" data-bs-target="#exampleModal">Click Here</a> if you need guidance completing this section.
    </div>
    <div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h1 class="modal-title fs-5" id="exampleModalLabel">Completing the Plex Section</h1>
          </div>
          <div class="modal-body">
            <a href="https://kometa.wiki/en/latest/config/plex/">Click Here</a> to visit the wiki for this connector<br>
            <br>
            Filling in your Plex URL and Token is mandatory as Kometa cannot run without access to a Plex Media Server.<br>
            <br>
            You cannot use <code>https://app.plex.tv</code> as your URL as that is invalid, you must provide the direct address you use to access your server.<br>
            <br>
            If you need help finding your Plex Authentication Token, please see Plex's <a href="https://support.plex.tv/articles/204059436-finding-an-authentication-token-x-plex-token/">support article</a>. Do not use the Plex Token found in Plex's <code>Preferences.xml</code> file and do not use the token that you get via <code>https://app.plex.tv</code>.<br>
            <br>
            You should press the <code>Validate</code> button to ensure that your URL and Token combination is valid and reachable. Once successfully connected, the wizard will fetch the Database Cache size and update the field in the form.<br>
            <br>
            Please note that using the <code>Optimize Database</code> option can make Plex unresponsive, as it is generally not contactable whilst it performs its optimizations. This is expected behavior.
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>
    <div class="form-floating">
      <input type="text" class="form-control" id="plex_url" name="plex_url" placeholder="http://127.0.0.1:32400" required=""> <label for="plex_url">Plex URL</label>
    </div>
    <div class="input-group input-group-lg">
      <input type="password" class="form-control" id="plex_token" name="plex_token" placeholder="Token" aria-label="Plex Token" required=""> <button class="btn btn-secondary" id="toggleApikeyVisibility" type="button">Show</button> <button class="btn btn-success" id="validatePlexButton" type="button">Validate</button>
    </div>
    <div id="plexStatusMessage" class="status-message"></div>
    <div class="form-floating">
      <input type="number" class="form-control" id="plex_db_cache" name="plex_db_cache" placeholder="Set the size of the Plex Database Cache (in Megabytes), default is 40" value="40" min="40" required=""> <label for="plex_db_cache">Database Cache Size (in mb)</label>
    </div>
    <div class="form-floating">
      <input type="number" class="form-control" id="plex_timeout" name="plex_timeout" placeholder="Amount of seconds to wait for Plex to respond, default is 60" value="60" min="60" required=""> <label for="plex_timeout">Timeout (in seconds)</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="checkbox" value="" id="plex_verify_ssl" checked> <label class="form-check-label" for="plex_verify_ssl">Verify SSL</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="checkbox" value="" id="plex_clean_bundles" checked> <label class="form-check-label" for="plex_clean_bundles">Clean bundles</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="checkbox" value="" id="plex_empty_trash"> <label class="form-check-label" for="plex_empty_trash">Empty trash</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="checkbox" value="" id="plex_optimize"> <label class="form-check-label" for="plex_optimize">Optimize database</label>
    </div>
    <hr class="hr">
    <div class="row">
      <div class="col">
        <a class="btn btn-secondary" role="button" href="/step/start">Previous</a>
      </div>
      <div class="col-6"></div>
      <div class="col d-flex justify-content-end align-items-center">
        <button class="btn btn-primary me-md-2" type="submit">Next</button>
      </div>
    </div>
  </div>
</form>
<script>
  // Save input values to sessionStorage on change
  document.getElementById('plex_url').addEventListener('input', function() {
    sessionStorage.setItem('plex_url', this.value);
  });
  document.getElementById('plex_token').addEventListener('input', function() {
    sessionStorage.setItem('plex_token', this.value);
  });
  document.getElementById('plex_db_cache').addEventListener('input', function() {
    sessionStorage.setItem('plex_db_cache', this.value);
  });
  document.getElementById('plex_timeout').addEventListener('input', function() {
    sessionStorage.setItem('plex_timeout', this.value);
  });
  document.getElementById('plex_verify_ssl').addEventListener('change', function() {
    sessionStorage.setItem('plex_verify_ssl', this.checked);
  });
  document.getElementById('plex_clean_bundles').addEventListener('change', function() {
    sessionStorage.setItem('plex_clean_bundles', this.checked);
  });
  document.getElementById('plex_empty_trash').addEventListener('change', function() {
    sessionStorage.setItem('plex_empty_trash', this.checked);
  });
  document.getElementById('plex_optimize').addEventListener('change', function() {
    sessionStorage.setItem('plex_optimize', this.checked);
  });

  // Load saved values from sessionStorage on page load
  document.addEventListener('DOMContentLoaded', function() {
    const savedPlexUrl = sessionStorage.getItem('plex_url');
    const savedPlexToken = sessionStorage.getItem('plex_token');
    const savedDbCache = sessionStorage.getItem('plex_db_cache');
    const savedTimeout = sessionStorage.getItem('plex_timeout');
    const savedVerifySsl = sessionStorage.getItem('plex_verify_ssl');
    const savedCleanBundles = sessionStorage.getItem('plex_clean_bundles');
    const savedEmptyTrash = sessionStorage.getItem('plex_empty_trash');
    const savedOptimize = sessionStorage.getItem('plex_optimize');

    if (savedPlexUrl) {
      document.getElementById('plex_url').value = savedPlexUrl;
    }
    if (savedPlexToken) {
      document.getElementById('plex_token').value = savedPlexToken;
    }
    if (savedDbCache) {
      document.getElementById('plex_db_cache').value = savedDbCache;
    }
    if (savedTimeout) {
      document.getElementById('plex_timeout').value = savedTimeout;
    }
    if (savedVerifySsl !== null) {
      document.getElementById('plex_verify_ssl').checked = JSON.parse(savedVerifySsl);
    }
    if (savedCleanBundles !== null) {
      document.getElementById('plex_clean_bundles').checked = JSON.parse(savedCleanBundles);
    }
    if (savedEmptyTrash !== null) {
      document.getElementById('plex_empty_trash').checked = JSON.parse(savedEmptyTrash);
    }
    if (savedOptimize !== null) {
      document.getElementById('plex_optimize').checked = JSON.parse(savedOptimize);
    }
  });

  document.getElementById('toggleApikeyVisibility').addEventListener('click', function() {
    const apikeyInput = document.getElementById('plex_token');
    const currentType = apikeyInput.getAttribute('type');
    apikeyInput.setAttribute('type', currentType === 'password' ? 'text' : 'password');
    this.textContent = currentType === 'password' ? 'Hide' : 'Show';
  });

  // Plex validation script
  document.getElementById('validatePlexButton').addEventListener('click', function() {
    const plexUrl = document.getElementById('plex_url').value;
    const plexToken = document.getElementById('plex_token').value;
    const plexStatusMessage = document.getElementById('plexStatusMessage');

    if (!plexUrl || !plexToken) {
      plexStatusMessage.textContent = 'Please enter both Plex URL and Token.';
      plexStatusMessage.style.display = 'block';
      return;
    }

    fetch('/validate_plex', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        plex_url: plexUrl,
        plex_token: plexToken
      })
    })
    .then(response => response.json())
    .then(data => {
      if (data.valid) {
        document.getElementById('plex_db_cache').value = data.db_cache;
        plexStatusMessage.textContent = 'Plex server validated successfully!';
        plexStatusMessage.style.color = '#75b798';
      } else {
        plexStatusMessage.textContent = 'Failed to validate Plex server. Please check your URL and Token.';
        plexStatusMessage.style.color = '#ea868f';
      }
      plexStatusMessage.style.display = 'block';
    })
    .catch(error => {
      console.error('Error validating Plex server:', error);
      plexStatusMessage.textContent = 'An error occurred while validating Plex server.';
      plexStatusMessage.style.color = '#ea868f';
      plexStatusMessage.style.display = 'block';
    });
  });
</script>
{% endblock %}
